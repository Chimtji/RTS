// MIT License

// Copyright (c) 2021 NedMakesGames

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

#include "NMGBladeGrassComputeHelpers.hlsl"

// This describes a vertex on the source mesh
struct SourceVertex {
    float3 positionOS;
};
// Source buffers, arranged as a vertex buffer and index buffer
StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceIndices;

// This describes a vertex on the generated mesh
struct GeneratedVertex {
    float3 positionOS;
    float3 normalOS;
    float2 uv;
};
// Source and index buffers for the generated mesh
RWStructuredBuffer<GeneratedVertex> _GeneratedVertices;
RWStructuredBuffer<int> _GeneratedIndices;

int _NumSourceTriangles;
float _BladeHeight;
float _BladeWidth;
float4x4 _Transform;

void GetCenterAndBasis(SourceVertex a, SourceVertex b, SourceVertex c, out float3 positionOS, out float3 normalOS, out float3x3 tsToOs){
    float3 posA = mul(_Transform, float4(a.positionOS, 1)).xyz;
    float3 posB = mul(_Transform, float4(b.positionOS, 1)).xyz;
    float3 posC = mul(_Transform, float4(c.positionOS, 1)).xyz;

    positionOS = GetTriangleCenter(posA, posB, posC);
    GetTriangleNormalAndTSMatrix(posA, posB, posC, normalOS, tsToOs);
}

GeneratedVertex MakeGeneratedPoint(float3 anchorOS, float3 normalOS, float2 dimensions, float3x3 tsToOs, float2 uv){
    float3 offsetTS = float3((uv.x - 0.5f) * dimensions.x, 0, uv.y * dimensions.y);
    float3 offsetOS = mul(tsToOs, offsetTS);

    GeneratedVertex output = (GeneratedVertex) 0;
    output.positionOS = anchorOS + offsetOS;
    output.normalOS = normalOS;
    output.uv = uv;
    return output;
}

// This is the number of threads to create per dispatch. This kernel only uses the
// x value, so you can fine tune that if needed
[numthreads(128, 1, 1)]
void Main(uint3 id : SV_DispatchThreadID) {
    // Disptaches can only be in chunks of 128, there might be more threads than number
    // of triangles. Return in that case
    if ((int)id.x >= _NumSourceTriangles) {
        return;
    }

    // Get the vertices which make up this triangle
    // The index array contains indices into the vertex array
    // Three values in the index array describe one triangle in the source mesh
    int sourceTriStart = id.x * 3;
    float3 positionOS, normalOS;
    float3x3 tsToOs;
    GetCenterAndBasis(
    _SourceVertices[_SourceIndices[sourceTriStart + 0]],
    _SourceVertices[_SourceIndices[sourceTriStart + 1]],
    _SourceVertices[_SourceIndices[sourceTriStart + 2]],
    positionOS, normalOS, tsToOs);

    float dimensions = float2(_BladeWidth, _BladeHeight);

    GeneratedVertex vertices[3];

    vertices[0] = MakeGeneratedPoint(positionOS, normalOS, dimensions, tsToOs, float2(0,0));
    vertices[1] = MakeGeneratedPoint(positionOS, normalOS, dimensions, tsToOs, float2(1,0));
    vertices[2] = MakeGeneratedPoint(positionOS, normalOS, dimensions, tsToOs, float2(0.5,1));

    int numGenVertices = 3;
    int numGenTriangles = 1;
    int numGenIndices = numGenTriangles * 3;
    int genIndexStart = id.x * numGenIndices;
    int genVertexStart = id.x * numGenVertices;

    for(int i = 0; i < 3; i++){
        _GeneratedVertices[genVertexStart + i] = vertices[i];
    }

    for(int i = 0; i < 3; i++){
        _GeneratedIndices[genIndexStart + i] = genVertexStart + i;
    }
}